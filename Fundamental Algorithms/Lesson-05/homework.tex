\documentclass[11pt]{article}
\pagestyle{empty}
\usepackage{color}
\usepackage{forest}
\usepackage{minted}
\usepackage{fancyhdr}
\usepackage{lastpage}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0pt}
\cfoot[R]{\thepage~of~\pageref{LastPage}}
\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

\begin{document}
\begin{center} {\Large\bf FA, Homework 5}  \\ Quentin McGaw (qm301) \\ 03/04/17
\end{center}

\begin{quote}
I wasn't sure anymore and I will tell you, it is a strange
process to feel one's mind changing, allowing ideas into
your brain which it had once considered unthinkable. I
cannot say it's painful, or particularly pleasurable, but
that it requires a certain relaxation of the hold one keeps
over oneself, and is to that degree both a thrill and a 
horror.
\\ -- from The Chess Garden, by Brooks Hansen
\end{quote}

\begin{enumerate}
\item \textbf{\textcolor{blue}{Some exercises in which $n$ is NOT the data size but we want
the answer in terms of $n$. (Answers in $\Theta$-land.)}}
    \begin{enumerate}
    \item \textbf{\textcolor{blue}{How long does {\tt MERGE-SORT} on $n^2$ items take?}}
        \\ For $n$ items, {\tt MERGE-SORT} takes $\Theta(n\log(n))$.
        \\ Hence for $n^2$ items, it takes $\Theta(n^2 \log(n^2)) = \Theta(2n^2 \log(n)) = \Theta(n^2 \log(n))$.
    \item \textbf{\textcolor{blue}{Suppose that when $n=2^m$, {\tt ANNA} takes time $\Theta(m^22^m)$.
    How long does it take as a function of $n$.}}
        \\ $n=2^m \Rightarrow m=\log_2(n)$
        \\ Hence {\tt ANNA} takes $\Theta((\log_2(n))^2\ 2^{\log_2(n)}) = \Theta((\log_2(n))^2\ n^{\log_2(2)}) = \Theta(n(\log_2(n))^2)$.
    \item \textbf{\textcolor{blue}{Suppose that when $n=2^m$, {\tt BOB} takes time $\Theta(5^m)$.
    How long does it take as a function of $n$.}}
        \\ $n=2^m \Rightarrow m=\log_2(n)$ therefore {\tt BOB} takes $\Theta(5^{\log_2(n)})$ time.
        \\ Or we can do $5^m = (2^{m})^c = n^c$ with $c = \log_2(5)$ so {\tt BOB} takes $\Theta(n^{\log_2(5)})$ time.
    \item \textbf{\textcolor{blue}{How long does {\tt COUNTING-SORT} take to sort $n^2$ items with
    each item in the range $0$ to $n^3-1$.}}
        \\ {\tt COUNTING-SORT} takes $\Theta(n+k)$ where $n$ is the number of items and $k$ is the maximum value of each item such that each item belongs to the range $[0, k-1]$.
        \\ In this case, we have $n^2$ items and $k = n^3$. Hence it will take $\Theta(n^2 + n^3) = \Theta(n^3)$ time.
    \item \textbf{\textcolor{blue}{How long does {\tt RADIX-SORT} take to sort $n^2$ items with
    each item in the range $0$ to $n^3-1$ and base $n$ is used.}}
        \\ The input array A has now a length of $n^2$ and we have $0 <= A[i] <= k^D = n^D = n^3 - 1$.
        \\ We have therefore $D = 3$ digits, each taking $n^2$. {\tt RADIX-SORT} takes therefore $\Theta(3n^2) = \Theta(n^2)$ time.
    \end{enumerate}
\item \textbf{\textcolor{blue}{Consider hashing with chaining using as hash function 
the sum of the numerical values of the letters (A=1,B=2,...,Z=26) mod 7. 
For example, h(JOE)=10+15+5mod7 = 2.  Starting with an empty table apply the following 
operations. Show the state of the hash table after each one. (In the
case of Search tell what places were examined and in what order.)}}
    \begin{enumerate}
    \item \textbf{\textcolor{blue}{Initial table}}
        \begin{center}
        \begin{tabular}{ | c | c | } 
            \hline
            Index & Key \\ 
            \hline\hline
            0 & \\
            \hline
            1 & \\
            \hline
            2 & \\
            \hline
            3 & \\
            \hline
            4 & \\
            \hline
            5 & \\
            \hline
            6 & \\
            \hline
        \end{tabular}
        \end{center}
    \item \textbf{\textcolor{blue}{Insert COBB}}
        \\ $h(COBB)=3+15+2+2\ mod\ 7 = 22\ mod\ 7 = 1$ hence we have this hash table:
        \begin{center}
        \begin{tabular}{ | c | c | } 
            \hline
            Index & Key \\ 
            \hline\hline
            0 & \\
            \hline
            1 & COBB\\
            \hline
            2 & \\
            \hline
            3 & \\
            \hline
            4 & \\
            \hline
            5 & \\
            \hline
            6 & \\
            \hline
        \end{tabular}
        \end{center}
    \item \textbf{\textcolor{blue}{Insert RUTH}}
        \\ $h(RUTH)=18+21+20+8\ mod\ 7 = 67\ mod\ 7 = 4$ hence we have this hash table:
        \begin{center}
        \begin{tabular}{ | c | c | } 
            \hline
            Index & Key \\ 
            \hline\hline
            0 & \\
            \hline
            1 & COBB\\
            \hline
            2 & \\
            \hline
            3 & \\
            \hline
            4 & RUTH\\
            \hline
            5 & \\
            \hline
            6 & \\
            \hline
        \end{tabular}
        \end{center}
    \item \textbf{\textcolor{blue}{Insert ROSE}}
        \\ $h(ROSE)=18+15+19+5\ mod\ 7 = 57\ mod\ 7 = 1$ hence we have this hash table:
        \begin{center}
        \begin{tabular}{ | c | c | } 
            \hline
            Index & Key \\ 
            \hline\hline
            0 & \\
            \hline
            1 & [ROSE, COBB]\\
            \hline
            2 & \\
            \hline
            3 & \\
            \hline
            4 & RUTH\\
            \hline
            5 & \\
            \hline
            6 & \\
            \hline
        \end{tabular}
        \end{center}
    \item \textbf{\textcolor{blue}{Search BUZ}}
        \\ $h(BUZ)=2+21+26\ mod\ 7 = 49\ mod\ 7 = 0$ 
        \\ Furthermore only the first entry of the table (index $0$) is checked.
        \\ Because there is no element, it does not even have to go through the linked list.
        \\
    \item \textbf{\textcolor{blue}{Insert DOC}}
        \\ $h(DOC)=4+15+3\ mod\ 7 = 22\ mod\ 7 = 1$ hence we have this hash table:
        \begin{center}
        \begin{tabular}{ | c | c | } 
            \hline
            Index & Key \\ 
            \hline\hline
            0 & \\
            \hline
            1 & [DOC, ROSE, COBB]\\
            \hline
            2 & \\
            \hline
            3 & \\
            \hline
            4 & RUTH\\
            \hline
            5 & \\
            \hline
            6 & \\
            \hline
        \end{tabular}
        \end{center}
    \item \textbf{\textcolor{blue}{Delete COBB}}
        \\ $h(COBB)=3+15+2+2\ mod\ 7 = 22\ mod\ 7 = 1$
        \\ Furthermore we have to search for COBB in the list present at index 1.
        \\ Once COBB is found, we remove the element from the list (or linked list).
        \\ The following table is then obtained:
        \begin{center}
        \begin{tabular}{ | c | c | } 
            \hline
            Index & Key \\ 
            \hline\hline
            0 & \\
            \hline
            1 & [DOC, ROSE]\\
            \hline
            2 & \\
            \hline
            3 & \\
            \hline
            4 & RUTH\\
            \hline
            5 & \\
            \hline
            6 & \\
            \hline
        \end{tabular}
        \end{center}
    \end{enumerate}
    
    The following Python code was written to simulate this problem with the same hashing table and it shows the same results.
    \begin{minted}{python}
from string import ascii_uppercase        
class HashingChaining(object):
    def __init__(self):
        self.hashtable = [[] for _ in range(7)]
        
    def hash(self, key): #key is in the form 'ABCD' in capitals
        sum = 0
        for C in key:
            sum += ascii_uppercase.find(C) + 1
        digest = sum % 7
        return digest
        
    def insert(self, key):
        index = self.hash(key)
        self.hashtable[index].insert(0, key)
        
    def search(self, key):
        index = self.hash(key)
        for sub_index in range(len(self.hashtable[index])):
            if key == self.hashtable[index][sub_index]:
                return index, sub_index
        return -1, -1
        
    def delete(self, key):
        index, sub_index = self.search(key)
        if index != -1: #key was found
            del self.hashtable[index][sub_index]
            
    def print_hashtable(self):
        print "Index Key"
        for i in range(7):
            print i, "   ", self.hashtable[i]
            
    def run(self):
        self.print_hashtable()
        self.insert("COBB")
        self.print_hashtable()
        self.insert("RUTH")
        self.print_hashtable()
        self.insert("ROSE")
        self.print_hashtable()
        self.search("BUZ")
        self.insert("DOC")
        self.print_hashtable()
        self.delete("COBB")
        self.print_hashtable()
        
h = HashingChaining()
h.run()
    \end{minted}

\item \textbf{\textcolor{blue}{Consider a Binary Search Tree $T$ with vertices $a,b,c,d,e,f,g,h$
and $ROOT[T]=a$ and with the following values ($N$ means NIL)
\begin{center}
\begin{tabular}{r|rrrrrrrr} 
vertex & a&b&c&d&e&f&g&h \\
parent & N&e&e&a&d&g&c&a  \\
left & h & N & N & e & c & N & f & N \\
right & d & N & g & N & b & N & N & N \\
key & 80 & 170 & 140 & 200 & 150 & 143 & 148 & 70
\end{tabular}
\end{center}
Draw a nice picture of the tree. Illustrate {\tt INSERT[i]} where {\tt key[i]=$100$}.}}
    \begin{center}
    \begin{forest}
    for tree={circle,draw, l sep=20pt}
    [{a=80}
        [{h=70}]
        [{d=200}
          [{e=150}
            [{c=140}
              [,phantom]
              [{g=148}
                [{f=143}]
                [,phantom]
              ]
            ]
            [{b=170}]
          ]
          [,phantom]
        ]
      ] 
    ]
    \end{forest}
    \end{center}
    Now instead of illustrating the insertion, I have wrote a Python code to build the binary tree as well as print statements when it inserts a node. The following code was used:
    \begin{minted}{python}
class Node(object):
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key
        
def insert(root, node):
    if root is None:
        root = node
    else:
        if root.val < node.val:
            if root.right is None:
                root.right = node
            else:
                insert(root.right, node)
        else:
            if root.left is None:
                root.left = node
            else:
                insert(root.left, node)
                    
def insert_verbose(root, node):
    if root is None:
        print "  No node, attributing new node here."
        root = node
    else:
        if root.val < node.val:
            print "New node has key",node.val,">",root.val,"(current node)"
            print "Checking the right side of node with key", root.val
            if root.right is None:
                print "  No node at right side, attributing new node here"
                root.right = node
            else:
                insert_verbose(root.right, node)
        else:
            print "New node has key",node.val,"<",root.val,"(current node)"
            print "Checking the right side of node, with key", root.val
            if root.left is None:
                print "  No node at left side, attributing new node here"
                root.left = node
            else:
                insert_verbose(root.left, node)
                    
if __name__ == "__main__":
    root = Node(80)
    insert(root, Node(70))
    insert(root, Node(200))
    insert(root, Node(150))
    insert(root, Node(140))
    insert(root, Node(170))
    insert(root, Node(148))
    insert(root, Node(143))
    insert_verbose(root, Node(100))
    \end{minted}
    The insert\_verbose() function is the relevant part here where it prints out how the key 100 is inserted in the binary search tree. The following is outputted by the program:
    \\ New node has key  $100  >  80$  (current node)
    \\ Checking the right side of node with key $80$
    \\ New node has key  $100  <  200$  (current node)
    \\ Checking the left side of node with key $200$
    \\ New node has key  $100  <  150$  (current node)
    \\ Checking the left side of node with key  $150$
    \\ New node has key  $100  <  140$  (current node)
    \\ Checking the left side of node with key $140$
    \\ No node at left side, attributing new node here
    \\
    \\ The final tree thus look like the following:
    \\   
    \begin{center}
    \begin{forest}
    for tree={circle,draw, l sep=20pt}
    [{a=80}
        [{h=70}]
        [{d=200}
          [{e=150}
            [{c=140}
              [100]
              [{g=148}
                [{f=143}]
                [,phantom]
              ]
            ]
            [{b=170}]
          ]
          [,phantom]
        ]
      ] 
    ]
    \end{forest}
    \end{center}
\end{enumerate}

\begin{quote}
If you want to have good ideas you must have many ideas.  Most of
them will be wrong, and what you have to learn is which ones to
throw away.
\\ -- Linus Pauling
\end{quote}

\end{document}